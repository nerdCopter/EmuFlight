# Builds the emuflight firmware
#
# After building, artifacts are released to a separate repository.
#
# Azure Pipelines requires the following extensions to be installed:
# - GitHub Tool: https://marketplace.visualstudio.com/items?itemName=marcelo-formentao.github-tools
#
# You'll also need to setup the following pipeline variables: (which can be in YML or in Azure-UI)
#     "releaseNotes" - This is used to add the release notes in the windows job in the build stage so they can be published as part of the github release in the release stage
#     "endpoint" - The name of the github endpoint link setup in AzDo - can be USERNAME or name of GitHub-PAT added into Azure-UI
#     "owner" - The owner of the repository to release to e.g. USERNAME
#     "repoName" - The name of the repository to release to e.g. myREPO
#         modded for two repoNames: destinationRepoName & destinationRepoNameTwo

variables:                                                    #default scope is Release Scope i.e. global across stages
  endpoint: nerdCopter
  owner: nerdCopter
  destinationRepoName: EmuFlight_nerdRepo                     #release destination
  destinationRepoNameTwo: EmuFlight_EmuClassic_nerdCopter     #release destination
  #firmVersion: ''
  releaseNotes: |+
     * not intended for public consumption.
     * may contain bugs / incomplete features.
     * do not use unless directed to do so.

name: $(Date:yyyyMMdd).$(BuildID)

trigger: none
#trigger:
#  branches:
#    include:
#    - '*'  # must quote since "*" is a YAML reserved character; we want a string
#    - master
#    - build/*

pr: none
#pr:
#  branches:
#    include:
#    - '*'  # must quote since "*" is a YAML reserved character; we want a string

stages:
- stage: Build
  jobs:
  - job: 'Linux'
    timeoutInMinutes: 360
    strategy:
      maxParallel: 3
      matrix:
        batch1:
#          GOAL: targets-group-1
          GOAL: FOXEERF405    # for testing purposes
          artifactName: emu1
        batch2:
#          GOAL: targets-group-2
          GOAL: HELIOSPRING   # for testing purposes
          artifactName: emu2
        batch3:
#          GOAL: targets-group-rest
          GOAL: STRIXF10      # for testing purposes
          artifactName: emu3

    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      clean: true
      fetchDepth: 50                  #lets shallow, but not too shallow for failure retries
      persistCredentials: true        #probably do not need this
    - script: function curl () { command curl --connect-timeout 30 --retry 5 "$@" ; } ;
      displayName: 'improve curl parameters'
    - script: make arm_sdk_install
      displayName: 'Install the build toolchain'
    - script: |
        myVersion="$(make version)"
        echo "##vso[task.setvariable variable=firmVersion;]$myVersion"
        echo $myVersion | tee release/firmVersion
      displayName: 'get make version'
    - script: make $(GOAL) -j2
      displayName: 'Build the Targets'
    - script: mkdir release; cp obj/*.hex release/
      displayName: 'Copy artifacts'
#    - script: rm -rf obj/*
#      displayName: 'Clean artifacts'
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Linux release'
      inputs:
        artifactName: $(artifactName)
        targetPath: '$(System.DefaultWorkingDirectory)/release/'

- stage: Release
  jobs:
  - job: Release

    steps:
    - checkout: self
      clean: true
      fetchDepth: 50                  #lets shallow, but not too shallow for failure retries
      persistCredentials: true        #probably do not need this
    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        targetPath: '$(Pipeline.Workspace)'
    - powershell: |
        Write-Output ("##vso[task.setvariable variable=today;]$(Get-Date -Format yyyyMMdd)")
        Write-Output ("today is $today ${today}")
        Write-Output "firmware version is: $firmVersion ${firmVersion}"
        Write-Output ($(today))
        Write-Output ($(firmVersion))
        Write-Output '$(today)'
        Write-Output '$(firmVersion)'
        Write-Output "okay, reading from file"
        firmVersion = Get-Content -Path '$(System.DefaultWorkingDirectory)/release/firmVersion'
        Write-Output ("##vso[task.setvariable variable=firmVersion;]$firmVersion")
        Write-Output "okay, read from file ^^"
        Write-Output "firmware version is: $firmVersion ${firmVersion}"
        Write-Output ($(firmVersion))
        Write-Output '$(firmVersion)'
      displayName: 'vars and vals'
      continueOnError: true
    - powershell: |
        Write-Output ($(firmVersion))
        Write-Output '$(firmVersion)'
      displayName: 'firmVersion outside'
      continueOnError: true
    - task: GitHubReleasePublish@1
      continueOnError: true
      inputs:
        githubEndpoint: '$(endpoint)'
        manuallySetRepository: true
        githubOwner: '$(owner)'
        githubRepositoryName: '$(destinationRepoName)'
        #githubTag: $(Date:yyyyMMdd).$(BuildID) #defaults to $(name) and this usually fails variables anyway
        githubReleaseTitle: '$(Build.Repository.Name): $(Build.SourceBranchName) ($(Build.BuildNumber))'
        githubReleaseDraft: true              #this will allow hiding until manually unsetting 'draft'
        githubReleasePrerelease: true         #make it a pre-release, we can manually unset also if appropriate
        githubIgnoreAssets: false
        githubReleaseAsset: '$(Pipeline.Workspace)/emu**/**'
        githubReuseRelease: false
        githubReuseDraftOnly: false
        githubSkipDuplicatedAssets: false
        githubEditRelease: true
        githubDeleteEmptyTag: false
        githubReleaseNotes: |+
          $(releaseNotes)

          #### Repo:Branch
          [$(Build.Repository.Name)]($(Build.Repository.Uri)):[$(Build.SourceBranchName)]($(Build.Repository.Uri)/tree/$(Build.SourceBranchName))

          #### Commit:
          [$(Build.SourceVersion)]($(Build.Repository.Uri)/commit/$(Build.SourceVersion))
          `$(Build.SourceVersionMessage)`

          #### Version:
          $(firmVersion)

          #### Azure Pipelines Debug:
          Build.SourceBranchName: $(Build.SourceBranchName)
          Build.Repository.Name: $(Build.Repository.Name)
          Build.Repository.ID: $(Build.Repository.ID)
          Build.Repository.Uri: $(Build.Repository.Uri)
          Build.RequestedFor: $(Build.RequestedFor)
          Build.QueuedBy: $(Build.QueuedBy)
          Build.Reason: $(Build.Reason)
          Build.BuildId: $(Build.BuildId)
          Build.BuildNumber: $(Build.BuildNumber)

    - task: GitHubReleasePublish@1
      continueOnError: true
      inputs:
        githubEndpoint: 'github-pat-for-azure'
        manuallySetRepository: true
        githubOwner: 'nerdCopter'
        githubRepositoryName: 'testBuilds'
        githubReleaseTitle: '$(Build.Repository.Name): $(Build.SourceBranchName) ($(Build.BuildNumber))'
        githubReleaseDraft: true
        githubReleasePrerelease: true
        githubIgnoreAssets: false
        githubReleaseAsset: '$(Pipeline.Workspace)/emu**/**'
        githubReuseRelease: false
        githubReuseDraftOnly: true
        githubSkipDuplicatedAssets: false
        githubEditRelease: false
        githubDeleteEmptyTag: false
        githubReleaseNotes: |+
          $(releaseNotes)

          #### Repo:Branch
          [$(Build.Repository.Name)]($(Build.Repository.Uri)):[$(Build.SourceBranchName)]($(Build.Repository.Uri)/tree/$(Build.SourceBranchName))

          #### Commit:
          [$(Build.SourceVersion)]($(Build.Repository.Uri)/commit/$(Build.SourceVersion))
          `$(Build.SourceVersionMessage)`

          #### Version:
          $(firmVersion)

          #### Azure Pipelines Debug:
          Build.SourceBranchName: $(Build.SourceBranchName)
          Build.Repository.Name: $(Build.Repository.Name)
          Build.Repository.ID: $(Build.Repository.ID)
          Build.Repository.Uri: $(Build.Repository.Uri)
          Build.RequestedFor: $(Build.RequestedFor)
          Build.QueuedBy: $(Build.QueuedBy)
          Build.Reason: $(Build.Reason)
          Build.BuildId: $(Build.BuildId)
          Build.BuildNumber: $(Build.BuildNumber)
