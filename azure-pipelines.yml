# Builds the emuflight firmware
#
# After building, artifacts are released to a separate repository.
#
# Azure Pipelines requires the following extensions to be installed:
# - GitHub Tool: https://marketplace.visualstudio.com/items?itemName=marcelo-formentao.github-tools
#
# You'll also need to setup the following pipeline variables: (which can be in YML or in Azure-UI)
#     "releaseNotes" - This is used to add the release notes in the windows job in the build stage so they can be published as part of the github release in the release stage
#     "endpoint" - The name of the github endpoint link setup in AzDo - can be USERNAME or name of GitHub-PAT added into Azure-UI
#     "owner" - The owner of the repository to release to e.g. USERNAME
#     "repoName" - The name of the repository to release to e.g. myREPO
#         modded for two repoNames: destinationRepoName & destinationRepoNameTwo

variables:                                                    #default scope is Release Scope i.e. global across stages
  endpoint: nerdCopter
  owner: nerdCopter
  destinationRepoName: EmuFlight_nerdRepo                     #release destination
  destinationRepoNameTwo: EmuFlight_EmuClassic_nerdCopter     #release destination
  releaseNotes: |+
     * not intended for public consumption.
     * may contain bugs / incomplete features.
     * do not use unless directed to do so.

name: $(Date:yyyyMMdd).$(BuildID)

trigger: none
#trigger:
#  branches:
#    include:
#    - '*'  # must quote since "*" is a YAML reserved character; we want a string
#    - master
#    - build/*

pr: none
#pr:
#  branches:
#    include:
#    - '*'  # must quote since "*" is a YAML reserved character; we want a string

stages:
- stage: Build
  jobs:
  - job: 'Linux'
    timeoutInMinutes: 360
    strategy:
      maxParallel: 3
      matrix:
        batch1:
#          GOAL: targets-group-1
          GOAL: FOXEERF405    # for testing purposes
          artifactName: emu1
        batch2:
#          GOAL: targets-group-2
          GOAL: HELIOSPRING   # for testing purposes
          artifactName: emu2
        batch3:
#          GOAL: targets-group-rest
          GOAL: STRIXF10      # for testing purposes
          artifactName: emu3

    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      clean: true
      fetchDepth: 50                  #lets shallow, but not too shallow for failure retries
      persistCredentials: true        #probably do not need this
    - script: function curl () { command curl --connect-timeout 30 --retry 5 "$@" ; } ;
      displayName: 'improve curl parameters'
    - script: make arm_sdk_install --debug=mj
      displayName: 'Install the build toolchain'
    - script: |
        myVersion="$(make version)"
        echo "##vso[task.setvariable variable=firmVersion;]$myVersion"
        echo "send firmware version to file $(Pipeline.Workspace)/variables/firmVersion"
        echo "debug: mkdir -p $(Pipeline.Workspace)/variables"
        mkdir -p '$(Pipeline.Workspace)/variables'
        echo "debug: echo $myVersion | tee $(Pipeline.Workspace)/variables/firmVersion"
        echo $myVersion | tee $(Pipeline.Workspace)/variables/firmVersion
        echo "debug: cat $(Pipeline.Workspace)/variables/firmVersion"
        cat $(Pipeline.Workspace)/variables/firmVersion
      displayName: 'make version'
    - script: make $(GOAL) -j2
      displayName: 'Build the Targets'
    - script: mkdir release; cp obj/*.hex release/
      displayName: 'Copy artifacts'
#    - script: rm -rf obj/*
#      displayName: 'Clean artifacts'
    # Publish the release folder as pipeline artifact
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Linux release'
      inputs:
        artifactName: $(artifactName)
        targetPath: '$(System.DefaultWorkingDirectory)/release/'
    # Publish the variables folder as pipeline artifact
    - publish: $(Pipeline.Workspace)/variables
      artifact: variables


- stage: Release
  jobs:
  - job: Release

    steps:
    - checkout: self
      clean: true
      fetchDepth: 50                  #lets shallow, but not too shallow for failure retries
      persistCredentials: true        #probably do not need this
    #Download the release folder pipeline artifact
    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        targetPath: '$(Pipeline.Workspace)'
    #Download the variables folder pipeline artifact
    - download: current
      artifact: variables
    - powershell: |
        Write-Output "reading file: $(Pipeline.Workspace)/variables/firmVersion"
        $firmVersion = Get-Content -Path "$(Pipeline.Workspace)/variables/firmVersion"
        Write-Output ("##vso[task.setvariable variable=firmVersion;]$firmVersion")
        Write-Output "firmware version is: $firmVersion"
      displayName: 'read variables artifact'
      continueOnError: true
    - powershell: |
        Write-Output 'var outside: $(firmVersion)'
      displayName: 'verify firmVersion outside task'
      continueOnError: true
    - task: GitHubReleasePublish@1
      continueOnError: true
      inputs:
        githubEndpoint: '$(endpoint)'
        manuallySetRepository: true
        githubOwner: '$(owner)'
        githubRepositoryName: '$(destinationRepoName)'
        #githubTag: $(Date:yyyyMMdd).$(BuildID) #defaults to $(name) and this usually fails variables anyway
        githubReleaseTitle: '$(Build.Repository.Name): $(Build.SourceBranchName) ($(Build.BuildNumber))'
        githubReleaseDraft: true              #this will allow hiding until manually unsetting 'draft'
        githubReleasePrerelease: true         #make it a pre-release, we can manually unset also if appropriate
        githubIgnoreAssets: false
        githubReleaseAsset: '$(Pipeline.Workspace)/emu**/**'
        githubReuseRelease: false
        githubReuseDraftOnly: false
        githubSkipDuplicatedAssets: false
        githubEditRelease: true
        githubDeleteEmptyTag: false
        githubReleaseNotes: |+
          $(releaseNotes)

          #### Repo:Branch
          [$(Build.Repository.Name)]($(Build.Repository.Uri)):[$(Build.SourceBranchName)]($(Build.Repository.Uri)/tree/$(Build.SourceBranchName))

          #### Commit:
          [$(Build.SourceVersion)]($(Build.Repository.Uri)/commit/$(Build.SourceVersion))
          `$(Build.SourceVersionMessage)`

          #### Version:
          $(firmVersion)

          #### Azure Pipelines Debug:
          Build.SourceBranchName: $(Build.SourceBranchName)
          Build.Repository.Name: $(Build.Repository.Name)
          Build.Repository.ID: $(Build.Repository.ID)
          Build.Repository.Uri: $(Build.Repository.Uri)
          Build.RequestedFor: $(Build.RequestedFor)
          Build.QueuedBy: $(Build.QueuedBy)
          Build.Reason: $(Build.Reason)
          Build.BuildId: $(Build.BuildId)
          Build.BuildNumber: $(Build.BuildNumber)

    - task: GitHubReleasePublish@1
      continueOnError: true
      inputs:
        githubEndpoint: 'github-pat-for-azure'
        manuallySetRepository: true
        githubOwner: 'nerdCopter'
        githubRepositoryName: 'testBuilds'
        githubReleaseTitle: '$(Build.Repository.Name): $(Build.SourceBranchName) ($(Build.BuildNumber))'
        githubReleaseDraft: true
        githubReleasePrerelease: true
        githubIgnoreAssets: false
        githubReleaseAsset: '$(Pipeline.Workspace)/emu**/**'
        githubReuseRelease: false
        githubReuseDraftOnly: true
        githubSkipDuplicatedAssets: false
        githubEditRelease: false
        githubDeleteEmptyTag: false
        githubReleaseNotes: |+
          $(releaseNotes)

          #### Repo:Branch
          [$(Build.Repository.Name)]($(Build.Repository.Uri)):[$(Build.SourceBranchName)]($(Build.Repository.Uri)/tree/$(Build.SourceBranchName))

          #### Commit:
          [$(Build.SourceVersion)]($(Build.Repository.Uri)/commit/$(Build.SourceVersion))
          `$(Build.SourceVersionMessage)`

          #### Version:
          $(firmVersion)

          #### Azure Pipelines Debug:
          Build.SourceBranchName: $(Build.SourceBranchName)
          Build.Repository.Name: $(Build.Repository.Name)
          Build.Repository.ID: $(Build.Repository.ID)
          Build.Repository.Uri: $(Build.Repository.Uri)
          Build.RequestedFor: $(Build.RequestedFor)
          Build.QueuedBy: $(Build.QueuedBy)
          Build.Reason: $(Build.Reason)
          Build.BuildId: $(Build.BuildId)
          Build.BuildNumber: $(Build.BuildNumber)

    # Publish pipeline artifacts
    # Publish (upload) a file or directory as a named artifact for the current run
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Pipeline.Workspace)'
        artifactName: 'artifacts drop'

    - task: cURLUploader@2
      inputs:
        files: '$(Pipeline.Workspace)/emu**/**'
        serviceEndpoint: 'BinTray-Dev'
        remotePath: 'nerdCopter_fork/$(Build.BuildNumber)-$(firmVersion)/$(Build.SourceBranchName)/'
#        options: "-H 'X-Bintray-Package:$(Build.SourceBranchName)' -H 'X-Bintray-Version:$(Build.BuildNumber)-$(firmVersion)'"
